---
title: "Latihan UAS MSR"
author: "Angga Fathan Rofiqy"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    self_contained: true
    thumbnails: false
    lightbox: true
    gallery: true
    highlight: tango
    code_folding: hide
    toc_depth: 5
    number_sections: false
    theme: flatly
    toc: yes
    toc_float:
      collapsed: true
      smooth_scroll: true
    fig_caption: true
---

# UAS Tahun Lalu

## Fungsi & Library

### Library

```{r setup, include=FALSE, echo=FALSE, warning=FALSE, message = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
#                      -=( Install & Load Package Function )=-
install_load <- function (package1, ...)  {   

   # convert arguments to vector
   packages <- c(package1, ...)

   # start loop to determine if each package is installed
   for(package in packages){

       # if package is installed locally, load
       if(package %in% rownames(installed.packages()))
          do.call('library', list(package))

       # if package is not installed locally, download, then load
       else {
          install.packages(package)
          do.call("library", list(package))
       }
   } 
}

install_load("MASS","dplyr","DT")
```

### Estimasi koefisien

```{r}
est.coeff <- function(x, y) {
  lm_model <- lm(y ~ x)
  coefficients(lm_model)
}
```

### SSE

```{r}
cal.SSE <- function(x, y, coefficients) {
  fitted_values <- coefficients[1] + coefficients[2] * x
  SSE <- sum((y - fitted_values)^2)
  SSE
}
```

### MSE

```{r}
cal.MSE <- function(x, y, coefficients) {
  SSE <- cal.SSE(x, y, coefficients)
  MSE <- SSE / length(y)
  MSE
}
```

### R-squared

```{r}
cal.R.sq <- function(x, y, coefficients) {
  fitted_values <- coefficients[1] + coefficients[2] * x
  SSE <- cal.SSE(x, y, coefficients)
  SST <- sum((y - mean(y))^2)
  R.squared <- 1 - SSE / SST
  R.squared
}
```

## Simulasi

### Pengaturan

```{r}
# Mengatur jumlah simulasi dan ukuran sampel 
num.simul <- 1000
sample.size <- 100

# Menetapkan skenario distribusi residual dengan variansi residual
res.var <- 0.25

# Membuat matriks untuk menyimpan hasil SSE, MSE, R-squared, dan koefisien.
results <- matrix(0, nrow = num.simul, ncol = 10)
```

### Monte Carlo

```{r}
for (i in 1:num.simul) {
  # Membangkitkan data
  x <- rnorm(sample.size)
  
  # Membangkitkan sisaan dengan distribusi normal
  res.norm <- rnorm(sample.size, mean = 0, sd = sqrt(res.var))
  
  # Membangkitkan sisaan dengan distribusi Poisson
  res.pois <- rpois(sample.size, lambda = res.var)
  
  # Membangkitkan respon data
  y.norm <- 5 + 2 * x + res.norm
  y.poiss <- 5 + 2 * x + res.pois
  
  # Menghitung koefisien estimasi
  coeff.nor <- est.coeff(x, y.norm)
  coeff.poiss <- est.coeff(x, y.poiss)
  
  # Menghitung SSE, MSE, dan R-squared
  SSE.normal <- cal.SSE(x, y.norm, coeff.nor)
  MSE.normal <- cal.MSE(x, y.norm, coeff.nor)
  R.squared.normal <- cal.R.sq(x, y.norm, coeff.nor)
  
  SSE.poisson <- cal.SSE(x, y.poiss, coeff.poiss)
  MSE.poisson <- cal.MSE(x, y.poiss, coeff.poiss)
  R.squared.poisson <- cal.R.sq(x, y.poiss, coeff.poiss)
  
  # Menyimpan hasil SSE, MSE, dan R-squared
  results[i, 1] <- SSE.normal
  results[i, 2] <- MSE.normal
  results[i, 3] <- R.squared.normal
  results[i, 4] <- SSE.poisson
  results[i, 5] <- MSE.poisson
  results[i, 6] <- R.squared.poisson
  
  # Menyimpan hasil koefisien
  results[i, 7] <- coeff.nor[1] # Normal intercept
  results[i, 8] <- coeff.nor[2] # Normal slope
  results[i, 9] <-  coeff.poiss[2] # Poisson intercept
  results[i, 10] <-  coeff.poiss[3] # Poisson slope
}
```

```{r}
# Menampilkan hasil
colnames(results) <- c(
  "Normal SSE", "Normal MSE", "Normal R-squared", "Poisson SSE", "Poisson MSE",
  "Poisson R-squared", "Normal Intercept", "Normal Slope", "Poisson Intercept", 
  "Poisson Slope"
)

result <- data.frame(
  "Mean" = colMeans(results),
  "Var"  = apply(results, 2, var)
) %>% format(., scientific = TRUE)

datatable(result)
```

# **Pendugaan Tak Bias**

## Library

```{r}
install_load("DT")
```

## Rataan & Median

### Pembangkitan Populasi

```{r fig.height=3.5, fig.width=10, dpi=300}
set.seed(86)

# Normal (0,1)
pop.norm = rnorm(10000000) 

# Eksponensial (1)
pop.exp = rexp(10000000)

par(mfrow = c(1, 2))
hist(pop.norm, main = "Sebaran Normal", 
     xlab = "Nilai", ylab = "Frekuensi", col = "#b4e69e")

hist(pop.exp, main = "Sebaran Eksponensial", 
     xlab = "Nilai", ylab = "Frekuensi", col = "#DE7C8A")
```

Visualisasi di atas, dapat terlihat bahwa sebaran setiap populasi berbeda-beda. Dengan nilai mean dan median setiap sebaran setiap populasi adalah sebagai berikut:

```{r}
mm <- data.frame(
  Sebaran = c("Normal", "Eksponensial"),
  Median  = c(median(pop.norm), median(pop.exp)),
  Mean    = c(mean(pop.norm), mean(pop.exp))
) %>% format(., scientific = TRUE)

datatable(mm)
```

Dapat terlihat bahwa nilai mean dan median cenderung sama ketika sebarannya simetris dan cenderung berbeda ketika sebarannya tidak simetris.

Ditentukan pula nilai n atau banyak sampel sebanyak 100 dan k atau banyak ulangan sebanyak 1000 untuk membuat sebaran contoh.

### Normal

```{r}
set.seed(86)
n = 100; k = 1000
norm = matrix(sample(pop.norm, n*k), k)
norm_mean = apply(norm, 1, mean)
norm_median = apply(norm, 1, median)

normal <- data.frame(
  "\ " = c("Sampel", "Populasi"), 
  mean = c(mean(norm_mean), mean(pop.norm)), 
  median = c(mean(norm_median), median(pop.norm))
) %>% mutate(across(-1, round, 5))

datatable(normal)
```

Dapat terlihat dengan banyak sampel sebanyak 100 dengan ulangan sebanyak 1000 kali, nilai mean dan median sampel cukup mendekati nilai parameternya. Hal ini menunjukan bahwa mean dan median sampel tidak bias terhadap parameternya. Lebih jelasnya, dapat dilihat dari visualisasi sebaran contoh di bawah ini.

```{r fig.height=3.5, fig.width=10, dpi=300}
par(mfrow = c(1, 2))
hist(norm_mean, main = "Mean", 
     xlab = "Nilai", ylab = "Frekuensi", col = "#b4e69e")
abline(v = mean(pop.norm), col = "red", lwd = 2)

hist(norm_median, main = "Median", 
     xlab = "Nilai", ylab = "Frekuensi", col = "#8DC16D")
abline(v=median(pop.norm), col = "red", lwd = 2)
```

Gambar menunjukan mean dan median contoh menyebar di antara mean dan median populasi yang menunjukan ketakbiasan mean dan median bagi sampel.

### **Eksponensial**

```{r}
set.seed(86)
n = 100; k = 1000
exp = matrix(sample(pop.exp, n*k), k)
exp_mean = apply(exp, 1, mean)
exp_median = apply(exp, 1, median)

expo <- data.frame(
  "\ " = c("Sampel", "Populasi"), 
  mean = c(mean(exp_mean), mean(pop.exp)), 
  median = c(mean(mean), median(pop.exp))
) %>% mutate(across(-1, round, 5))

datatable(expo)
```

Dapat terlihat dengan banyak sampel sebanyak 100 dengan ulangan sebanyak 1000 kali, nilai mean dan median sampel cukup mendekati nilai parameternya. Hal ini menunjukan bahwa mean dan median sampel tidak bias terhadap parameternya. Lebih jelasnya, dapat dilihat dari visualisasi sebaran contoh di bawah ini

```{r fig.height=3.5, fig.width=10, dpi=300}
par(mfrow = c(1, 2))
hist(exp_mean, main = "Mean", 
     xlab = "Nilai", ylab = "Frekuensi", col = "#E4B3BA")
abline(v = mean(pop.exp), col = "blue", lwd = 2)

hist(exp_median, main = "Median", 
     xlab = "Nilai", ylab = "Frekuensi", col = "#DE7C8A")
abline(v=median(pop.exp), col = "blue", lwd = 2)
```

Gambar menunjukan mean dan median contoh menyebar di antara mean dan median populasi yang menunjukan ketakbiasan mean dan median bagi sampel.

### **Kesimpulan**

Dari pengerjaan yang telah dilakukan, dapat disimpulkan bahwa rata-rata (mean) atau median contoh merupakan penduga tak bias bagi rata-rata atau median populasi pada sebaran apapun (baik simetris maupun tidak simetris).

## Ragam

```{r}
# Fungsi Pendugaan Ragam
ragam <- function(x, sample = TRUE) {
  n <- length(x)
  mean_x <- mean(x)
  sse <- sum((x - mean_x)^2)
  if (sample) {
    return(sse / (n - 1))
  } else {
    return(sse / n)
  }
}
```

Jika sample `TRUE` (default), maka yang digunakan adalah pembagi n-1, dan jika `FALSE` pembaginya adalah n.

Dalam hal ini, kita akan menggunakan pop.norm yang telah digunakan pada soal sebelumnya sebagai populasinya. Akan dilakukan simulasi untuk membandingkan kedua pembagi ini.

```{r}
k = 1000 # Ulangan
n = 30 # Jumlah sampel

ragam_contoh_n <- numeric(0) # Pembagi n
ragam_contoh_n_1 <- numeric(0) # Pembagi n-1

for (i in 1:k) {
  contoh <- sample(pop.norm, n)
  ragam_contoh_n[i] <- ragam(contoh, sample = F)
  ragam_contoh_n_1[i] <- ragam(contoh, sample = T)
}
```

Didapat hasil sebagai berikut:

```{r}
var.pop = ragam(pop.norm, F)
var.pop
```

```{r}
var <- data.frame(
  Pembagi = c("n", "n-1"),
  Rataan_Ragam = c(mean(ragam_contoh_n), mean(ragam_contoh_n_1)),
  Selisih_Dengan_Ragam_Populasi = c(
    abs(mean(ragam_contoh_n) - var.pop), 
    abs(mean(ragam_contoh_n_1) - var.pop)
  )
) %>% mutate(across(-1, round, 5))

datatable(var)
```

Dari hasil di atas, dapat terlihat bahwa pembagi n-1 memiliki hasil yang lebih tidak bias daripada pada pembagi n.Â Hal ini menunjukan bahwa pembagi n berbias untuk ragam contoh.

# **Selang Kepercayaan**

## Fungsi Selang Kepercayaan

### Normal

```{r}
ci_normal <- function(sample, confidence_level) {
  n <- length(sample)
  mean_sample <- mean(sample)
  sd_sample <- sd(sample)
  error <- qnorm(1 - (1 - confidence_level) / 2) * (sd_sample / sqrt(n))
  lower_bound <- mean_sample - error
  upper_bound <- mean_sample + error
  return(c(lower_bound, upper_bound))
}
```

### Seragam

```{r}
ci_uniform <- function(sample, confidence_level) {
  n <- length(sample)
  mean_sample <- mean(sample)
  sd_sample <- sqrt((n + 1) / (12 * n)) * (max(sample) - min(sample))
  error <- qnorm(1 - (1 - confidence_level) / 2) * (sd_sample / sqrt(n))
  lower_bound <- mean_sample - error
  upper_bound <- mean_sample + error
  return(c(lower_bound, upper_bound))
}
```

### Eksponensial

```{r}
ci_exponential <- function(sample, confidence_level) {
  n <- length(sample)
  mean_sample <- mean(sample)
  sd_sample <- mean_sample / sqrt(n)
  error <- qnorm(1 - (1 - confidence_level) / 2) * (sd_sample / sqrt(n))
  lower_bound <- mean_sample - error
  upper_bound <- mean_sample + error
  return(c(lower_bound, upper_bound))
}
```

## Pengujian

```{r}
# Set confidence level
confidence_level <- 0.95

# Ukuran contoh
sample_sizes <- c(10, 30, 100)
```

### Normal

```{r}
set.seed(86)
# Distribusi normal
population_mean <- 10
population_sd <- 2

cat("Penduga Selang Kepercayaan untuk Distribusi Normal\n")
for (n in sample_sizes) {
  cat("Dengan Ukuran Contoh", n, ":\n")
  sample_normal <- rnorm(n, mean = population_mean, sd = population_sd)
  confidence_interval <- ci_normal(sample_normal, confidence_level)
  cat("Selang kepercayaan:", confidence_interval, "\n\n")
}
```

### Seragam

```{r}
set.seed(8)
# Distribusi seragam
population_min <- 5
population_max <- 15

cat("Penduga Selang Kepercayaan untuk Distribusi Seragam\n")
for (n in sample_sizes) {
  cat("Dengan Ukuran Contoh", n, ":\n")
  sample_uniform <- runif(n, min = population_min, max = population_max)
  confidence_interval <- ci_uniform(sample_uniform, confidence_level)
  cat("Selang kepercayaan:", confidence_interval, "\n\n")
}
```

### **Eksponensial**

```{r}
set.seed(8)
# Distribusi eksponensial
population_rate <- 0.1

cat("Penduga Selang Kepercayaan untuk Distribusi Eksponensial\n")
for (n in sample_sizes) {
  cat("Dengan Ukuran Contoh", n, ":\n")
  sample_exponential <- rexp(n, rate = population_rate)
  confidence_interval <- ci_exponential(sample_exponential, confidence_level)
  cat("Selang kepercayaan:", confidence_interval, "\n\n")
}
```

### **Visualisasi**

```{r fig.height=5, fig.width=10, dpi=300}
# Set seed
set.seed(86)

# Set ukuran sampel
sample_sizes <- c(10, 30, 100, 300, 1000)

# Set tingkat kepercayaan
confidence_level <- 0.95

# Set parameter populasi
population_mean <- 10
population_sd <- 2

# Inisialisasi vektor untuk menyimpan lebar interval kepercayaan
confidence_intervals <- numeric(length(sample_sizes))

# Hitung lebar interval kepercayaan untuk setiap ukuran sampel
for (i in 1:length(sample_sizes)) {
  sample_normal <- rnorm(sample_sizes[i], mean = population_mean, sd = population_sd)
  confidence_interval <- ci_normal(sample_normal, confidence_level)
  confidence_intervals[i] <- confidence_interval[2] - confidence_interval[1]
}

# Plot lebar interval kepercayaan terhadap ukuran sampel
plot(sample_sizes, confidence_intervals, type = "n", 
     xlab = "Ukuran Sampel", ylab = "Lebar Interval Kepercayaan", 
     main = "Lebar Interval Kepercayaan Terhadap Ukuran Sampel")
lines(sample_sizes, confidence_intervals, type = "b", lwd = 2, col = "#4493CA")
points(sample_sizes, confidence_intervals, pch = 16, col = "#D44155", cex = 1.5)
```

Bisa dilihat bahwa, semakin besar ukuran sampel, maka semakin kecil lebar interval kepercayaannya.
